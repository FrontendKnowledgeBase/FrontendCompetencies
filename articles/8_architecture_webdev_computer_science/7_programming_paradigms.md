# Функциональное, объектно-ориентированное, реактивное, императивное и декларативное программирование

Разные подходы к программированию помогают решать задачи наиболее удобным способом. В этой статье рассмотрим основные парадигмы программирования: функциональную, объектно-ориентированную, реактивную, императивную и декларативную. Также обсудим классы и прототипы.

---

## 1. Функциональное программирование (FP)

### Основные принципы
- **Чистые функции**: Функции не изменяют внешнее состояние и зависят только от входных данных.
- **Неизменяемость (Immutability)**: Данные не изменяются после создания.
- **Функции высшего порядка**: Функции, принимающие другие функции как аргументы или возвращающие их.

### Пример (JavaScript)
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
```

### Преимущества
- Лёгкость тестирования и отладки.
- Предсказуемость кода.

### Недостатки
- Меньшая производительность из-за неизменяемости.
- Требует понимания функциональных концепций.

---

## 2. Объектно-ориентированное программирование (OOP)

### Основные принципы
- **Инкапсуляция**: Сокрытие деталей реализации.
- **Наследование**: Возможность создавать новые классы на основе существующих.
- **Полиморфизм**: Использование одного интерфейса для разных типов.

### Классы и Прототипы в JavaScript
- **Классы**: Современный синтаксис, упрощающий работу с объектами.
- **Прототипы**: Механизм для наследования, лежащий в основе JavaScript.

#### Пример с классами
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} издает звук.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} лает.`);
  }
}

const dog = new Dog('Бобик');
dog.speak(); // Бобик лает.
```

#### Пример с прототипами
```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} издает звук.`);
};

const animal = new Animal('Лев');
animal.speak();
```

### Преимущества
- Удобство моделирования реальных объектов.
- Повторное использование кода через наследование.

### Недостатки
- Сложность поддержки при большом количестве зависимостей.
- Трудности с параллельным программированием.

---

## 3. Императивное программирование

### Основные принципы
- **Пошаговые инструкции**: Указывает "как" достичь результата.
- Использование переменных, циклов и условий.

### Пример (JavaScript)
```javascript
let sum = 0;
for (let i = 1; i <= 5; i++) {
  sum += i;
}
console.log(sum); // 15
```

### Преимущества
- Простота понимания для новичков.
- Контроль над процессом выполнения.

### Недостатки
- Код может быть более сложным и запутанным.
- Сложно отслеживать состояния.

---

## 4. Декларативное программирование

### Основные принципы
- Указывает "что" нужно сделать, а не "как".
- Полагание на встроенные функции и абстракции.

### Пример (JavaScript)
```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15
```

### Преимущества
- Более чистый и лаконичный код.
- Лёгкость понимания.

### Недостатки
- Ограничения гибкости в специфических задачах.

---

## 5. Реактивное программирование

### Основные принципы
- Работа с потоками данных и реакцией на изменения.
- Использование "наблюдаемых" (observables) и подписчиков (subscribers).

### Пример с RxJS
```javascript
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

const stream = of(1, 2, 3);
stream.pipe(
  map(x => x * 2)
).subscribe(console.log); // 2, 4, 6
```

### Преимущества
- Удобство работы с асинхронными операциями.
- Высокая масштабируемость.

### Недостатки
- Крутая кривая обучения.
- Более сложная отладка.

---

## Итоговые вопросы для подготовки

1. Чем отличаются функциональное и объектно-ориентированное программирование?
2. Какие преимущества и недостатки имеет реактивное программирование?
3. В чём разница между императивным и декларативным подходами?
4. Как работают классы и прототипы в JavaScript?
5. В каких случаях предпочтительнее использовать каждую парадигму?

**Совет:** Попробуйте реализовать один и тот же алгоритм с использованием разных парадигм, чтобы лучше понять их особенности.

