# Алгоритмы: Принципы, оценка сложности, O(n), O(log n)

Алгоритмы лежат в основе программирования и позволяют решать задачи эффективно. Понимание принципов их работы, умение оценивать сложность и анализировать производительность — важные навыки для любого разработчика. В этом материале рассмотрим основы оценки сложности, основные обозначения, типы сложностей и примеры.

## 1. Принципы работы алгоритмов

### Что такое алгоритм?
Алгоритм — это последовательность шагов для решения задачи. Хороший алгоритм должен быть:
- **Правильным**: давать верный результат для всех входных данных.
- **Эффективным**: работать за минимальное время и использовать как можно меньше памяти.
- **Универсальным**: применимым для решения задач определённого класса.

### Примеры задач
1. Поиск максимального элемента в массиве.
2. Сортировка списка чисел.
3. Проверка числа на простоту.

---

## 2. Оценка сложности алгоритмов

### Почему это важно?
Сложность алгоритма показывает, как растёт время выполнения или объём памяти при увеличении размера входных данных. Это помогает выбирать наиболее подходящий алгоритм для задачи.

### Типы сложности
1. **Временная сложность**: Сколько времени требуется для выполнения алгоритма.
2. **Пространственная сложность**: Сколько памяти используется алгоритмом.

### Ассимптотическая нотация
Используется для описания поведения алгоритма на больших объёмах данных:
- **O(1)**: Константное время (не зависит от размера данных).
- **O(log n)**: Логарифмическая сложность (быстро уменьшающееся количество операций).
- **O(n)**: Линейная сложность (время пропорционально размеру данных).
- **O(n log n)**: Линейно-логарифмическая сложность (используется в эффективных алгоритмах сортировки).
- **O(n^2)**: Квадратичная сложность (используется в простых сортировках, например, пузырьковой).
- **O(2^n)**: Экспоненциальная сложность (для задач с комбинаторным ростом, таких как перебор).
- **O(n!)**: Факториальная сложность (например, полный перебор перестановок).

---

## 3. Разбор сложностей

### O(1): Константная сложность
- **Описание**: Алгоритм выполняется за фиксированное время, независимо от размера данных.
- **Пример**:
```python
# Получение первого элемента массива
arr = [1, 2, 3, 4, 5]
print(arr[0])
```
**Разбор**: Доступ к элементу массива происходит за фиксированное время.

---

### O(log n): Логарифмическая сложность
- **Описание**: Количество операций уменьшается пропорционально логарифму от размера данных.
- **Пример**:
```python
# Двоичный поиск в отсортированном массиве
arr = [1, 3, 5, 7, 9, 11]
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```
**Разбор**: На каждом шаге массив делится пополам.

---

### O(n): Линейная сложность
- **Описание**: Время выполнения пропорционально размеру входных данных.
- **Пример**:
```python
# Подсчёт суммы элементов массива
arr = [1, 2, 3, 4, 5]
sum = 0
for num in arr:
    sum += num
print(sum)
```
**Разбор**: Для массива из `n` элементов потребуется `n` операций.

---

### O(n log n): Линейно-логарифмическая сложность
- **Описание**: Алгоритмы сортировки, такие как Merge Sort или Quick Sort.
- **Пример**:
```python
# Сортировка слиянием (Merge Sort)
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
**Разбор**: Каждый уровень деления массива добавляет `log n`, а слияние всех элементов требует `O(n)`.

---

### O(n^2): Квадратичная сложность
- **Описание**: Используется в алгоритмах с вложенными циклами.
- **Пример**:
```python
# Сортировка пузырьком
arr = [5, 2, 4, 1, 3]
for i in range(len(arr)):
    for j in range(len(arr) - i - 1):
        if arr[j] > arr[j + 1]:
            arr[j], arr[j + 1] = arr[j + 1], arr[j]
```
**Разбор**: Два вложенных цикла выполняют `n * (n-1)` операций.

---

### O(2^n): Экспоненциальная сложность
- **Описание**: Используется в задачах перебора всех комбинаций, например, в рекурсивных алгоритмах без мемоизации.
- **Пример**:
```python
# Рекурсивный подсчёт чисел Фибоначчи
 def fibonacci(n):
     if n <= 1:
         return n
     return fibonacci(n-1) + fibonacci(n-2)
```
**Разбор**: Для каждого вызова выполняются два новых вызова, что приводит к экспоненциальному росту.

---

### O(n!): Факториальная сложность
- **Описание**: Используется в задачах перебора всех возможных перестановок.
- **Пример**:
```python
# Генерация всех перестановок
from itertools import permutations
arr = [1, 2, 3]
print(list(permutations(arr)))
```
**Разбор**: Количество перестановок растёт как факториал от количества элементов.

---

## Таблица сложностей алгоритмов

| Сложность        | Обозначение | Пример задачи                          | Производительность           |
|------------------|-------------|---------------------------------------|-----------------------------|
| **Константная**  | O(1)        | Доступ к элементу массива             | Быстрая                     |
| **Логарифмическая** | O(log n)   | Двоичный поиск                       | Быстрая                     |
| **Линейная**     | O(n)        | Проход по массиву                     | Умеренная                   |
| **Линейно-логарифмическая** | O(n log n) | Сортировка слиянием                 | Хорошая                     |
| **Квадратичная** | O(n^2)      | Сортировка пузырьком                  | Медленная для больших данных |
| **Экспоненциальная** | O(2^n)  | Рекурсивный перебор                   | Очень медленная              |
| **Факториальная** | O(n!)       | Перестановки                         | Крайне медленная             |

---

## Итоговые вопросы для подготовки
1. Чем отличаются O(n) от O(log n)?
2. Как определить временную сложность алгоритма?
3. Какие алгоритмы имеют сложность O(1)?
4. Почему O(n log n) эффективнее O(n^2)?
5. В каких задачах возможна факториальная сложность?

**Совет:** Практикуйтесь в написании алгоритмов с разной сложностью, чтобы научиться быстро определять их производительность.

